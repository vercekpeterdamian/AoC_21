Hello - from c:\Users\peter\.vscode\extensions\jaredly.reason-vscode-1.7.13\bin.native.exe.hot.exe
Previous log location: C:\Users\peter\AppData\Local\Temp\lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/peter/FMF/2._letnik/PROG_1/AoC_21/project_windows.ml","languageId":"ocaml","version":1,"text":"let preberi_datoteko ime_datoteke =\n  let chan = open_in ime_datoteke in\n  let vsebina = really_input_string chan (in_channel_length chan) in\n  close_in chan;\n  vsebina\n\nlet izpisi_datoteko ime_datoteke vsebina =\n  let chan = open_out ime_datoteke in\n  output_string chan vsebina;\n  close_out chan\n\nmodule List = struct\n  include List\n\n  let int_list l = List.map int_of_string l\n\n  let sum l =\n    let rec sum' a = function [] -> a | x :: xs -> sum' (a + x) xs in\n    sum' 0 l\n\n  let lines = String.split_on_char '\\n'\nend\n\nmodule type Solver = sig\n  val naloga1 : string -> string\n\n  val naloga2 : string -> string -> string\nend\n\nmodule Solver0 : Solver = struct\n  let cost_fun x = (x / 3) - 2\n\n  let rec full_cost x =\n    let c_cost = cost_fun x in\n    if c_cost <= 0 then 0 else c_cost + full_cost c_cost\n\n  let naloga1 data =\n    let lines = List.lines data in\n    lines |> List.int_list\n    |> List.fold_left (fun s x -> s + cost_fun x) 0\n    |> string_of_int\n\n  let naloga2 data _part1 =\n    data |> List.lines |> List.int_list |> List.map full_cost |> List.sum\n    |> string_of_int\nend\n\n\n\n(* Tukaj re-definirajte funkcijo naloga1 in naloga2 *)\nmodule Solver1 : Solver = struct\n  let naloga1 data = \n    let lines = List.int_list (List.lines data) in\n    let rec aux acc =\n      function\n      | [] -> string_of_int acc\n      | g1 :: g2 :: r when g1 < g2 -> aux (acc + 1) (g2 :: r)\n      | g :: r -> aux acc r\n    in\n    aux 0 lines\n\n  let naloga2 data _part1= \n    let lines = List.int_list (List.lines data) in\n    let rec aux acc = \n      function\n      | [] -> string_of_int acc\n      | g1 :: g2 :: g3 :: g4 :: r when (g1 + g2 + g3) < (g2 + g3 + g4) -> aux (acc + 1) (g2 :: g3 :: g4 :: r)\n      | _ :: r -> aux acc r\n    in\n    aux 0 lines\nend\n\n\n\nmodule Solver2 : Solver = struct\n  let naloga1 data =\n    let lines = List.lines data in\n    let rec aux globina naravnost = function\n      | [] -> string_of_int (globina * naravnost)\n      | g :: r ->\n        let navodilo = String.split_on_char ' ' g in\n        match navodilo with\n        | \"forward\" :: x :: _ -> aux globina (naravnost + int_of_string x) r\n        | \"up\" :: x :: _ -> aux (globina - int_of_string x) naravnost r\n        | \"down\" :: x :: _ -> aux (globina + int_of_string x) naravnost r \n        | _ -> failwith \"nekaj ne deluje\"\n    in\n    aux 0 0 lines\n\n\n  let naloga2 data _part1 =\n    let lines = List.lines data in\n    let rec aux globina naravnost smer = function\n      | [] -> string_of_int (globina * naravnost)\n      | g :: r ->\n        let navodilo = String.split_on_char ' ' g in\n        match navodilo with\n        | \"up\" :: x :: _ -> aux globina naravnost (smer - int_of_string x) r\n        | \"down\" :: x :: _ -> aux globina naravnost (smer + int_of_string x) r\n        | \"forward\" :: x :: _ -> aux (globina + smer * (int_of_string x)) (naravnost + int_of_string x) smer r\n        | _ -> failwith \"Cry about it\"\n    in\n    aux 0 0 0 lines\n    \n\nend\n\n\n\nmodule Solver3: Solver = struct\n  (* https://caml.inria.fr/pub/old_caml_site/FAQ/FAQ_EXPERT-eng.html#strings *)\n  let explode s =\n    let rec exp i l =\n     if i < 0 then l else exp (i - 1) (s.[i] :: l) in\n    exp (String.length s - 1) []\n\n  let rec sestej_seznama sez1 sez2 =\n    match (sez1, sez2) with\n    | ([], []) -> []\n    | (g1 :: r1, g2 :: r2) -> (g1 +. g2) :: sestej_seznama r1 r2\n    | _ -> failwith \"SEZNAMA NISTA ENAKO DOLGA!!\"\n\n  let rec primerjaj_v_bin (pr, sez) =\n    match sez with\n    | [] -> []\n    | a :: r -> (if 2. *. a > pr then 1. else 0.) :: primerjaj_v_bin (pr, r)\n\n  let sez_bin_v_flt sez =\n    let rec aux acc i = function\n      | [] -> acc\n      | 1. :: rr -> aux (acc +. 2. ** i) (i +. 1.) rr\n      | _ :: rr -> aux acc (i +. 1.) rr\n    in\n    aux 0. 0. sez\n\n  let rec get_gamma counter_list ct = function\n    | [] -> ((float_of_int ct), counter_list)\n    | st :: rep -> \n      let sezc = st\n        |> explode\n        |> List.map (fun x -> if x = '1' then 1. else 0.)\n      in\n      if counter_list = [] then get_gamma sezc (ct + 1) rep\n      else get_gamma (sestej_seznama counter_list sezc) (ct + 1) rep\n\n  let naloga1 data =\n    let lines = List.lines data in \n    let gamma = lines \n      |> get_gamma [] 0 \n      |> primerjaj_v_bin\n      |> List.rev \n      |> sez_bin_v_flt \n    in\n    string_of_int (int_of_float (gamma *. ( 2. ** 12. -. 1. -. gamma)))\n\n\n  let kisik_krit (ct, x) =\n    if 2 * x >= ct then '1' else '0'\n\n  let ogljik_krit (ct, x) =\n    if 2 * x < ct then '1' else '0'\n\n  let rec prestej_enice acc cot = function\n    | [] -> (acc, cot)\n    | x :: rep ->\n      if (List.nth x 0)  = '1' then prestej_enice (acc + 1) (cot + 1) rep\n      else prestej_enice (acc + 1) cot rep\n\n  let rec sestavi_s_kriterijem acc dolz cot general krit i sez =\n    if i = 0 then\n      let hocem = general (prestej_enice 0 0 sez) in\n      sestavi_s_kriterijem acc dolz cot general hocem (i + 1) sez\n    else\n    if i < 12 then\n      match sez with\n      | x :: [] when acc = [] -> x\n      | [] -> \n        let novek = general (dolz, cot) in\n        sestavi_s_kriterijem [] 0 0 general novek (i + 1) acc\n      | x :: rep ->\n        if (List.nth x (i - 1)) <> krit then\n          sestavi_s_kriterijem acc dolz cot general krit i rep\n        else\n          if (List.nth x i) = '1' then\n            sestavi_s_kriterijem (x :: acc) (dolz + 1) (cot + 1) general krit i rep\n          else\n            sestavi_s_kriterijem (x :: acc) (dolz + 1) cot general krit i rep\n    else\n      match sez with\n      | [] -> failwith \"Predam se\"\n      | x :: rep ->\n        if (List.nth x 11) = krit then x\n        else sestavi_s_kriterijem [] 0 0 general krit 12 rep\n\n\n    \n  let naloga2 data _part1 =\n      let lines = data \n        |> List.lines\n        |> List.map explode\n      in\n      let kisik = lines\n        |> sestavi_s_kriterijem [] 0 0 kisik_krit '0' 0 \n        |> List.rev\n        |> List.map (fun x -> if x = '1' then 1. else 0.)\n        |> sez_bin_v_flt\n      in\n      let ogljik = lines\n        |> sestavi_s_kriterijem [] 0 0 ogljik_krit '0' 0\n        |> List.rev\n        |> List.map (fun x -> if x = '1' then 1. else 0.)\n        |> sez_bin_v_flt\n      in\n      (kisik *. ogljik) |> int_of_float |> string_of_int\nend\n\n\n\nmodule Solver4: Solver = struct\n  type bingo = (int list list) * (int list)\n\n  let rec pretvori_podatke accVELIK acc i = function\n    | [] -> accVELIK\n    | x when i = 5 -> \n      pretvori_podatke (acc :: accVELIK) [] 0 x\n    | x :: rep ->\n      pretvori_podatke accVELIK (x :: acc) (i + 1) rep\n\n  let rec zbrisi_prvih i = function\n    | [] -> []\n    | _ :: rep when i = 1 -> rep\n    | x :: rep -> x :: (zbrisi_prvih (i - 1) rep)\n\n  let rec pristej_na_mesto i j = function\n    | x :: r when i = 0 -> (x + j) :: r\n    | x :: r -> x :: pristej_na_mesto (i - 1) j r\n    | _ -> failwith \"Indeks prevelik\"\n\n  let rec mogoce_bingo (matrika, seznamck) =\n    if List.exists (fun x -> x = 5) seznamck then true else false\n\n  let zakljuci iscem (matrika, q) =\n    let a = matrika\n      |> List.map (List.fold_left (+) 0)\n      |> List.fold_left (+) 0\n    in\n    string_of_int (a * iscem)\n\n  let rec preisci_odstrani_shrani iscem vr st bing = \n    match vr, st, bing with\n    | _, 5, _ -> preisci_odstrani_shrani iscem (vr + 1) 0 bing\n    | 5, _, _ -> bing\n    | vr, st, (matrika, seznamck) -> \n      let vrstica = List.nth matrika vr in\n      if iscem = List.nth vrstica st then\n        let seznamck_spremenjen = seznamck\n          |> pristej_na_mesto st 1\n          |> pristej_na_mesto (vr + 5) 1\n        in\n        let matrika_spremenjena = matrika\n          |> List.map (List.map (fun x -> if iscem = x then 0 else x))\n        in\n        (matrika_spremenjena, seznamck_spremenjen)\n      else\n      preisci_odstrani_shrani iscem vr (st + 1) (matrika, seznamck)\n\n  let rec izpelji_obravnavo i seznam bingeci =\n    let iscem = List.nth seznam i in\n    let rec aux acc iscem = function\n      | [] -> izpelji_obravnavo (i + 1) seznam acc\n      | glava :: rep -> \n        let nova = preisci_odstrani_shrani iscem 0 0 glava in\n        match nova with\n        | x when mogoce_bingo x -> zakljuci iscem x\n        | x -> \n          aux (x :: acc) iscem rep\n    in \n    aux [] iscem bingeci\n\n  let naloga1 data = \n    let lines = List.lines data\n    in\n    let navodila = (List.nth lines 0)\n      |> String.split_on_char ','\n      |> List.map int_of_string\n      |> List.map (fun x -> x + 1)\n    in\n    let sneg = [0; 0; 0; 0; 0; 0; 0; 0; 0; 0] in\n    let bingoti = lines\n      |> List.filter (fun x -> if x <> \"\" then true else false)\n      |> pretvori_podatke [] [] 0\n      |> List.map (List.map (String.split_on_char ' '))\n      |> List.map (List.map (List.filter (fun x -> if x <> \"\" then true else false)))\n      |> List.map (List.map (List.map int_of_string))\n      |> List.map (List.map (List.map (fun x -> x + 1)))\n      |> List.map (fun x -> (x, sneg))\n    in\n    izpelji_obravnavo 0 navodila bingoti\n\n  let naloga2 data _part1 = \"\"\nend\n\n\n\nmodule Solver5: Solver = struct\n  let naloga1 data = \"\"\n\n  let naloga2 data _part1 = \"\"\nend\n\n\n\n(* Poženemo zadevo *)\nlet choose_solver : string -> (module Solver) = function\n  | \"0\" -> (module Solver0)\n  | \"1\" -> (module Solver1)\n  | \"2\" -> (module Solver2)\n  | \"3\" -> (module Solver3)\n  | \"4\" -> (module Solver4)\n  | \"5\" -> (module Solver5)\n  | _ -> failwith \"Ni še rešeno\"\n\nlet main () =\n  let day = Sys.argv.(1) in\n  print_endline (\"Solving DAY: \" ^ day);\n  let (module Solver) = choose_solver day in\n  let input_data = preberi_datoteko (\"data/day_\" ^ day ^ \".in\") in\n  let p1_start = Sys.time () in\n  let part1 = Solver.naloga1 input_data in\n  let t1_time = Sys.time () -. p1_start in\n  print_endline \"PART 1:\";\n  print_endline part1;\n  print_endline (\"Taken: \" ^ string_of_float t1_time ^ \"s\");\n  let p2_start = Sys.time () in\n  let part2 = Solver.naloga2 input_data part1 in\n  let t2_time = Sys.time () -. p2_start in\n  print_endline \"PART 2:\";\n  print_endline part2;\n  print_endline (\"Taken: \" ^ string_of_float t2_time ^ \"s\");\n  print_endline (\"Total: \" ^ string_of_float (t1_time +. t2_time) ^ \"s\");\n  izpisi_datoteko (\"out/day_\" ^ day ^ \"_1.out\") part1;\n  izpisi_datoteko (\"out/day_\" ^ day ^ \"_2.out\") part2;\n  ()\n\nlet _ = main ()\n"}}}
